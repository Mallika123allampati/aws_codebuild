import jenkins.*;
import jenkins.model.*;

// List all services paths for which docker image will be builded if something changed
def jobsByPath = [
   "job1/": "job1",
    "job2/": "job2_1",
    "job3/": "job3"
  ]

def jobsToRun(build, jobsByPath) {
  // Listing changes files since last build
  def changeLogSets = build.changeSets
  def changedFiles = []
  for (int i = 0; i < changeLogSets.size(); i++) {
    def entries = changeLogSets[i].items
    for (int j = 0; j < entries.length; j++) {
      def entry = entries[j]
      def files = new ArrayList(entry.affectedFiles)
      for (int k = 0; k < files.size(); k++) {
        def file = files[k]
        changedFiles.add(file.path)
      }
    }
  }

  // Listing jobs to run
  jobsToRun = [:]
  for (entry in jobsByPath) {
    def pattern = entry.key
    for (int i = 0; i < changedFiles.size(); i++) {
      def file = changedFiles[i]
      if (file.contains(pattern)) {
        def jobName = entry.value
        jobsToRun[jobName] = true
        break
      }
    }
  }

  jobsToRun
}

def runTerraform(dockerImageTag) {
  stage('Terraform Init') {     
    sh 'terraform init -no-color'
  }
                
  stage('Terraform Apply') {     
    sh ("""terraform apply \
    -var=\"docker_image_tag=${dockerImageTag}\" \
    -auto-approve -no-color""")
  }
}

def addJob2_2IfJob2_1Present(jobsToRun) {
  def job2_1Present = false
  jobsToRun.each{ 
    if(it.key == 'job2_1' && it.value) {
      job2_1Present == true
    }
  }
  if(job2_1Present) {
    jobsToRun["job2_2"] = true
  }
}

node {
  //This can be moved to global variables or external property file
  def AWS_ACCOUNT_ID="246005639140"
  def AWS_DEFAULT_REGION="eu-central-1" 

  stage('Clean workspace') {      
    sh "rm -r *"           
  }

  stage('Logging into AWS ECR') {      
    sh "aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com"           
  }
        
  stage('Cloning Git') {           
    checkout([
      $class: 'GitSCM', 
      branches: [[name: '*/master']], 
      doGenerateSubmoduleConfigurations: false, 
      extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'CodeDir']], 
      submoduleCfg: [], 
      userRemoteConfigs: [[credentialsId: '', url: 'https://github.com/demask/aws_codebuild_codedeploy_nodeJs_demo.git']]])                 
  }

  stage('Cloning Terraform Git') {           
    checkout([
      $class: 'GitSCM', 
      branches: [[name: '*/master']], 
      doGenerateSubmoduleConfigurations: false, 
      extensions: [[$class: 'RelativeTargetDirectory', relativeTargetDir: 'TerraformDir']], 
      submoduleCfg: [], 
      userRemoteConfigs: [[credentialsId: '', url: 'https://github.com/demask/aws_codebuild_codedeploy_nodeJs_demo_terraform.git']]])                 
  } 

  dir("${env.WORKSPACE}/CodeDir"){  
    def jobs
    stage('Checking for jobs to run') {
      jobs = jobsToRun(currentBuild, jobsByPath)
      addJob2_2IfJob2_1Present(jobs)
    }
    
    if(jobs){
      def newImageMap = [:]

      jobs.each{
          def IMAGE_REPO_NAME
          def IMAGE_TAG
          def REPOSITORY_URI
          def DOCKERFILE

          //This can be extracted to function to prevent code repeating
          if(it.key == 'job1' && it.value) {
              DOCKERFILE = 'Dockerfile'
              IMAGE_REPO_NAME="job1"
          } else if(it.key == 'job2_1' && it.value) {
              DOCKERFILE = 'Dockerfile'
              IMAGE_REPO_NAME="job2_1"
          } else if(it.key == 'job2_2' && it.value) {
              DOCKERFILE = 'Dockerfile'
              IMAGE_REPO_NAME="job2_2"     
          }
          
          REPOSITORY_URI = "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${IMAGE_REPO_NAME}"
          IMAGE_TAG = sh (script: 'git rev-parse --short HEAD',returnStdout: true).trim()

          if(IMAGE_REPO_NAME && IMAGE_TAG && REPOSITORY_URI && DOCKERFILE) {
              stage('Building image') {
                  dockerImage = docker.build("${IMAGE_REPO_NAME}:${IMAGE_TAG}", "-f ${DOCKERFILE} .")                         
              }
   
              stage('Pushing to ECR') {         
                  sh "docker tag ${IMAGE_REPO_NAME}:${IMAGE_TAG} ${REPOSITORY_URI}:${IMAGE_TAG}"
                  sh "docker push ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com/${IMAGE_REPO_NAME}:${IMAGE_TAG}"                            
              }

              newImageMap[IMAGE_REPO_NAME] = IMAGE_TAG
          }
      }

      def job2AlreadyCreated = false
      newImageMap.each{
        if(it.key == 'job1') {
          dir("${env.WORKSPACE}/TerraformDir/dev/task-definitions/job1"){
            runTerraform(it.value)     
          } 
        }
        if(!job2AlreadyCreated && (it.key == 'job2_1' || it.key == 'job2_2')) {
          dir("${env.WORKSPACE}/TerraformDir/dev/task-definitions/job2"){
            runTerraform(it.value)     
          } 
          job2AlreadyCreated = true
        }
      }
    }
  }
}